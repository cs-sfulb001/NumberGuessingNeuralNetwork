/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package neuralnetwork;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.Hashtable;
import weka.classifiers.functions.SMO;
import weka.classifiers.functions.supportVector.RBFKernel;
import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;


public class App {
    public int[][][] getDatatoClassify(){
        int [][][] returnValue;
        try{
            File trainingData = new File("CatigorizeData.txt");
            Scanner TDR = new Scanner(trainingData);
            int set = 0;
            int line =0;
            String DataSets=TDR.nextLine();
            returnValue = new int[Integer.parseInt(DataSets)][][];
            String DataDepth = TDR.nextLine();
            returnValue[0]=new int[Integer.parseInt(DataDepth)][];
            while(TDR.hasNextLine()){
                String Data = TDR.nextLine();
                String[] splitData = Data.split("", Data.length());
            
                returnValue[set][line]=new int[splitData.length];
                for(int i=0;i<splitData.length;i++)
                {
                    returnValue[set][line][i]=Integer.parseInt(splitData[i]);
                }
                line++;
                if(line==Integer.parseInt(DataDepth)){
                set++;
                line=0;
                if(TDR.hasNextLine())
                    returnValue[set]=new int[Integer.parseInt(DataDepth)][];
                }
            }
            TDR.close();
            return returnValue;
        } catch(FileNotFoundException e){
            e.printStackTrace();
        }
        return returnValue = new int[1][][];
    }
    public static void main(int[] args) {}
    public void run(){
        System.out.println("Start");
        App NeuralNetwork = new App();
        int[][][] TrainingData;
        int[] Numbers;
        try{
            File trainingData = new File("TrainingData.txt");
            Scanner TDR = new Scanner(trainingData);
            int set = 0;
            int line =0;
            String DataSets=TDR.nextLine();
            TrainingData = new int[Integer.parseInt(DataSets)][][];
            Numbers = new int[Integer.parseInt(DataSets)];
            String DataDepth = TDR.nextLine();
            System.out.println(Integer.toString(TrainingData.length));
            TrainingData[0]=new int[Integer.parseInt(DataDepth)][];
            while(TDR.hasNextLine()){
                String Data = TDR.nextLine();
                String[] splitData = Data.split("", Data.length());
                if(splitData.length==1){
                    Numbers[set]=Integer.parseInt(splitData[0]);
                    set++;
                    if(TDR.hasNextLine())
                        TrainingData[set]=new int[Integer.parseInt(DataDepth)][];
                    line=0;
                }
                else{
                    TrainingData[set][line]=new int[splitData.length];
                    for(int i=0;i<splitData.length;i++)
                    {
                        TrainingData[set][line][i]=Integer.parseInt(splitData[i]);
                    }
                    line++;
                }
            }
            NeuralNetwork.buildClassifierWithTrainingData(TrainingData, Numbers);
        } catch(FileNotFoundException e){
            e.printStackTrace();
        }
        int[][] results = NeuralNetwork.Categorize(NeuralNetwork.getDatatoClassify());
        System.out.println("The results from the Categorize file is");
        for(int i=0;i<results.length;i++){
            System.out.println("For data set "+(i+1));
            for(int number : results[i]){
                System.out.println("    "+number);
            }
        }
    }
    SMO svm;
    double gamma;
    double C;
    FastVector attrInfo;
    int[] Categories;
  
    public App() {
      this.svm = new SMO();
      this.gamma = 0.01;
      this.C = 1.0;
      this.attrInfo = new FastVector();
    }
  
    public FastVector fastV(int[] data) {
      FastVector result = new FastVector(data.length);
      for (int s : data) {
        result.addElement(Integer.toString(s));
      }
      return result;
    }
    /*Assumes input intgers and categories are in the correct order*/
    public String[] MakeTrainingData(int[][][] Filled, int[] number) {
      int size = Filled.length;
      String[] ReturnValue = new String[size];
      for (int i = 0; i < Filled.length; i++) {
        StringBuffer nextLine = new StringBuffer();
        for (int line[] : Filled[i]) {
          for(int value: line)
            {
                nextLine.append(Integer.toString(value) + ",");
            }
        }
        nextLine.append(number[i]);
        ReturnValue[i] = nextLine.toString();
      }
      return ReturnValue;
    }
  
    public Attribute MakeCategoryAttribute(int[] UniqueCategories) {
      return new Attribute("Categories", fastV(UniqueCategories));
    }
  
    public FastVector MakeAttributeList(int count, Attribute Categories) {
      FastVector ReturnValue = new FastVector();
      for (int i =0;i<count;i++) {
        ReturnValue.addElement(new Attribute("Pix"+Integer.toString(i)));
      }
      ReturnValue.addElement(Categories);
      return ReturnValue;
    }
  
    public void Training(FastVector AttributeList, String[] TrainingData, Attribute Categories) {
      String[] options = {"-N", "0", "-V", "-1"};
      try {
        this.svm.setOptions(options);
      } catch (Exception e) {
        e.printStackTrace();
      }
      Instances training = new Instances("TrainingData", AttributeList, TrainingData.length);
      training.setClass(Categories);
      this.attrInfo = new FastVector();
      for (int i = 0; i < AttributeList.size(); i++) {
        this.attrInfo.addElement(AttributeList.elementAt(i));
      }
      for (String sdata : TrainingData) {
        String[] values = sdata.split(",");
        Instance instance = new DenseInstance(values.length);
        for (int i = 0; i < values.length - 1; i++) {
          instance.setValue(i, Double.parseDouble(values[i]));
        }
        instance.setValue(Categories, values[values.length - 1]);
        training.add(instance);
      }
      try {
        this.svm.setKernel(new RBFKernel(training, 25007, this.gamma));
      } catch (Exception e) {
        e.printStackTrace();
      }
      this.svm.setC(this.C);
      try {
        this.svm.buildClassifier(training);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    public void buildClassifierWithTrainingData( int[][][] Filled, int[] Number) {
      this.Categories = FindUniqueCategories(Number);
      Attribute CategoryAttribute = MakeCategoryAttribute(this.Categories);
      String[] TrainingData = MakeTrainingData(Filled, Number);
      FastVector AttributeList = MakeAttributeList(Filled[0].length*Filled[0][0].length, CategoryAttribute);
      Training(AttributeList, TrainingData, CategoryAttribute);
    }
  
    public static int[] FindUniqueCategories(int[] Categories) {
      FastVector Collection = new FastVector();
      Collection.addElement(Categories[0]);
      Hashtable<Integer, Integer> dic = new Hashtable<Integer, Integer>();
      dic.put(Categories[0], 1);
      for (int cat : Categories) {
        if (dic.get(cat) == null) {
          Collection.addElement(cat);
          dic.put(cat, 1);
        }
      }
      int[] returnValue = new int[Collection.size()];
      for (int i = 0; i < Collection.size(); i++) {
        returnValue[i] = (int) Collection.get(i);
      }
      return returnValue;
    }
  
    private int[] getGuesses(double[] classified, double maxValue, int size) {
      int[] guesses = new int[size];
      int slot = 0;
      for (int i = 0; i < classified.length; i++) {
        if (classified[i] == maxValue) {
          guesses[slot] = this.Categories[i];
          slot++;
          if (slot == size) {
            break;
          }
        }
      }
      return guesses;
    }
  
    public int[][] Categorize(int[][][] Filled) {
      int[][] returnValue = new int[Filled.length][];
      Instances classificationInstances = new Instances("toBeClassified", this.attrInfo, 1);
      int rowSize=Filled[0][0].length;
      for (int i = 0; i < Filled.length; i++) {
        Instance testInstance = new DenseInstance(Filled[i].length*Filled[i][0].length);
        testInstance.setDataset(classificationInstances);
        for (int j=0;j<Filled[i].length;j++) {
            for(int c=0;c<Filled[i][j].length;c++)
            {
                testInstance.setValue(j*rowSize+c, Filled[i][j][c]);
            }
        }
        double classified[] = {-1};
        try {
          classified = this.svm.distributionForInstance(testInstance);
        } catch (Exception e) {
          e.printStackTrace();
        }
        double max = 0;
        int size = 0;
        for (double value : classified) {
          if (value > max) {
            max = value;
            size = 1;
          } else if (value == max) {
            size++;
          }
        }
        returnValue[i] = getGuesses(classified, max, size);
      }
      return returnValue;
    }
  
    public void OptimizeSVMParam(int[][][] Filled, int[] Num) {
      double gamma_L = this.gamma;
      double bGamma = this.gamma;
      double gamma_U = this.gamma / gamma_L;
      int M = 10;
      double C_L = this.C;
      double C_U;
      double B_C = this.C;
      double bestAccuracy = .9;
      double bestPrecision = .9;
      for (int i = 0; i < M; ++i) {
  
        this.gamma = gamma_L + (double) i * (gamma_U - gamma_L) / (double) (M - 1);
        C_U = B_C / C_L;
        for (int j = 0; j < M; ++j) {
          this.C = C_L + (double) j * (C_U - C_L) / (double) (M - 1);
          buildClassifierWithTrainingData(Filled, Num);
          int[][] Results = Categorize(Filled);
          double Accuracy = getAccuracy(Num, Results);
          double Precision = getPrecision(Results);
          if (bestAccuracy < Accuracy && bestPrecision < Precision) {
            bGamma = this.gamma;
            B_C = this.C;
            bestAccuracy = Accuracy;
            bestPrecision = Precision;
          }
          this.svm = new SMO();
        }
      }
      this.gamma = bGamma;
      this.C = B_C;
    }
  
    private double getAccuracy(int[] Control, int[][] Results) {
      int numCorrect = 0;
      for (int i = 0; i < Control.length; i++) {
        for (int Cat : Results[i]) {
          if (Control[i]==Cat) {
            numCorrect++;
          }
        }
      }
      return (double) numCorrect / Control.length;
    }
  
    private double getPrecision(int[][] Results) {
      int Overguess = 0;
      for (int[] CatList : Results) {
        Overguess += CatList.length - 1;
      }
      return 1 - (double) Overguess / Results.length;
    }
}
